<html>
<head>
<title>csc.nl.euro</title>
</head>
<body>
csc.nl.euro
<style>
.coverage pre {float: left; margin: 0px 1em; border: none;
               padding: 0px; }
.num pre { margin: 0px }
.nocov, .nocov pre {background-color: #faa}
.cov, .cov pre {background-color: #cfc}
div.coverage div { clear: both; height: 1.1em}
</style>
<div class="stats">
Covered: 329 lines<br/>
Missed: 20 lines<br/>
Skipped 67 lines<br/>
Percent: 94 %<br/>

</div>
<div class="coverage">
<div class="cov"><span class="num"><pre>  1</pre></span><pre>import string</pre></div>
<div class="cov"><span class="num"><pre>  2</pre></span><pre>from csc.nl import NLTools, get_nl</pre></div>
<div class="cov"><span class="num"><pre>  3</pre></span><pre>import re</pre></div>
<div class="skip"><span class="num"><pre>  4</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>  5</pre></span><pre>def doctest_globals():</pre></div>
<div class="cov"><span class="num"><pre>  6</pre></span><pre>    en_nl = get_nl('en')</pre></div>
<div class="cov"><span class="num"><pre>  7</pre></span><pre>    return locals()</pre></div>
<div class="skip"><span class="num"><pre>  8</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>  9</pre></span><pre>class lazy_property(object):</pre></div>
<div class="cov"><span class="num"><pre> 10</pre></span><pre>    def __init__(self, func):</pre></div>
<div class="cov"><span class="num"><pre> 11</pre></span><pre>        '''</pre></div>
<div class="cov"><span class="num"><pre> 12</pre></span><pre>        A lazy decorator. Runs a function only once to get a</pre></div>
<div class="cov"><span class="num"><pre> 13</pre></span><pre>        property's value; after that, the precomputed value is used.</pre></div>
<div class="skip"><span class="num"><pre> 14</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 15</pre></span><pre>        Replace expensive computations in __init__ with this.</pre></div>
<div class="cov"><span class="num"><pre> 16</pre></span><pre>        '''</pre></div>
<div class="cov"><span class="num"><pre> 17</pre></span><pre>        self.func = func</pre></div>
<div class="cov"><span class="num"><pre> 18</pre></span><pre>        self.__name__ = func.__name__</pre></div>
<div class="cov"><span class="num"><pre> 19</pre></span><pre>        self.__doc__ = func.__doc__</pre></div>
<div class="cov"><span class="num"><pre> 20</pre></span><pre>        self.__dict__.update(func.__dict__)</pre></div>
<div class="skip"><span class="num"><pre> 21</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 22</pre></span><pre>    def __get__(self, instance, cls):</pre></div>
<div class="cov"><span class="num"><pre> 23</pre></span><pre>        assert self.__name__ not in instance.__dict__</pre></div>
<div class="cov"><span class="num"><pre> 24</pre></span><pre>        result = instance.__dict__[self.__name__] = self.func(instance)</pre></div>
<div class="cov"><span class="num"><pre> 25</pre></span><pre>        return result</pre></div>
<div class="skip"><span class="num"><pre> 26</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 27</pre></span><pre>    @staticmethod</pre></div>
<div class="cov"><span class="num"><pre> 28</pre></span><pre>    def preset(cls, name, val):</pre></div>
<div class="nocov"><span class="num"><pre> 29</pre></span><pre>        cls.__dict__[name] = val</pre></div>
<div class="skip"><span class="num"><pre> 30</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 31</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 32</pre></span><pre>class EuroNL(NLTools):</pre></div>
<div class="cov"><span class="num"><pre> 33</pre></span><pre>    &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 34</pre></span><pre>    A language that generally follows our assumptions about European languages,</pre></div>
<div class="cov"><span class="num"><pre> 35</pre></span><pre>    including:</pre></div>
<div class="skip"><span class="num"><pre> 36</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 37</pre></span><pre>    - Words are made of uppercase and lowercase letters, which are variant</pre></div>
<div class="cov"><span class="num"><pre> 38</pre></span><pre>      forms of each other, and apostrophes, which are kind of special.</pre></div>
<div class="cov"><span class="num"><pre> 39</pre></span><pre>    - Words are separated by spaces or punctuation.</pre></div>
<div class="skip"><span class="num"><pre> 40</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 41</pre></span><pre>    Only the subclasses of EuroNL -- :class:`StemmedEuroNL` and</pre></div>
<div class="cov"><span class="num"><pre> 42</pre></span><pre>    :class:`LemmatizedEuroNL` -- implement all of the NLTools operations.</pre></div>
<div class="cov"><span class="num"><pre> 43</pre></span><pre>    &quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre> 44</pre></span><pre>    # TODO: Refactor this so that stemming languages and lemmatizing languages</pre></div>
<div class="skip"><span class="num"><pre> 45</pre></span><pre>    # aren't mixed up.</pre></div>
<div class="skip"><span class="num"><pre> 46</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 47</pre></span><pre>    def __init__(self, lang):</pre></div>
<div class="cov"><span class="num"><pre> 48</pre></span><pre>        self.lang = lang</pre></div>
<div class="skip"><span class="num"><pre> 49</pre></span><pre>        </pre></div>
<div class="cov"><span class="num"><pre> 50</pre></span><pre>    @lazy_property</pre></div>
<div class="cov"><span class="num"><pre> 51</pre></span><pre>    def blacklist(self):</pre></div>
<div class="cov"><span class="num"><pre> 52</pre></span><pre>        from csc.nl.models import FunctionClass</pre></div>
<div class="cov"><span class="num"><pre> 53</pre></span><pre>        return set(self.canonicalize(x) for x in</pre></div>
<div class="cov"><span class="num"><pre> 54</pre></span><pre>                   FunctionClass.objects.get(name='blacklist').function_word_set(self.lang))</pre></div>
<div class="skip"><span class="num"><pre> 55</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 56</pre></span><pre>    @lazy_property</pre></div>
<div class="cov"><span class="num"><pre> 57</pre></span><pre>    def old_stopwords(self):</pre></div>
<div class="cov"><span class="num"><pre> 58</pre></span><pre>        '''Old stopwords (ConceptNet 3)'''</pre></div>
<div class="cov"><span class="num"><pre> 59</pre></span><pre>        from csc.nl.models import FunctionClass</pre></div>
<div class="cov"><span class="num"><pre> 60</pre></span><pre>        return FunctionClass.objects.get(name='stop_old').function_word_set(self.lang)</pre></div>
<div class="skip"><span class="num"><pre> 61</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 62</pre></span><pre>    @lazy_property</pre></div>
<div class="cov"><span class="num"><pre> 63</pre></span><pre>    def stopwords(self):</pre></div>
<div class="cov"><span class="num"><pre> 64</pre></span><pre>        '''new version (ConceptNet 3.5 and 4)'''</pre></div>
<div class="cov"><span class="num"><pre> 65</pre></span><pre>        from csc.nl.models import FunctionClass</pre></div>
<div class="cov"><span class="num"><pre> 66</pre></span><pre>        return FunctionClass.objects.get(name='stop').function_word_set(self.lang)</pre></div>
<div class="skip"><span class="num"><pre> 67</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 68</pre></span><pre>    @lazy_property</pre></div>
<div class="cov"><span class="num"><pre> 69</pre></span><pre>    def frequencies(self):</pre></div>
<div class="cov"><span class="num"><pre> 70</pre></span><pre>        from csc.nl.models import Frequency</pre></div>
<div class="cov"><span class="num"><pre> 71</pre></span><pre>        return set([x.text for x in</pre></div>
<div class="cov"><span class="num"><pre> 72</pre></span><pre>                    Frequency.objects.filter(language__id=self.lang)])</pre></div>
<div class="skip"><span class="num"><pre> 73</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 74</pre></span><pre>    @lazy_property</pre></div>
<div class="cov"><span class="num"><pre> 75</pre></span><pre>    def swapdict(self):</pre></div>
<div class="cov"><span class="num"><pre> 76</pre></span><pre>        from csc.nl.models import AutoreplaceRule</pre></div>
<div class="cov"><span class="num"><pre> 77</pre></span><pre>        swapdict = {}</pre></div>
<div class="cov"><span class="num"><pre> 78</pre></span><pre>        for replacerule in AutoreplaceRule.objects.filter(language__id=self.lang,</pre></div>
<div class="cov"><span class="num"><pre> 79</pre></span><pre>                                                          family='swap4'):</pre></div>
<div class="cov"><span class="num"><pre> 80</pre></span><pre>            swapdict[replacerule.match] = replacerule.replace_with</pre></div>
<div class="cov"><span class="num"><pre> 81</pre></span><pre>        return swapdict</pre></div>
<div class="skip"><span class="num"><pre> 82</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 83</pre></span><pre>    @lazy_property</pre></div>
<div class="cov"><span class="num"><pre> 84</pre></span><pre>    def autocorrect(self):</pre></div>
<div class="cov"><span class="num"><pre> 85</pre></span><pre>        from csc.nl.models import AutoreplaceRule</pre></div>
<div class="cov"><span class="num"><pre> 86</pre></span><pre>        autocorrect = {}</pre></div>
<div class="cov"><span class="num"><pre> 87</pre></span><pre>        for replacerule in AutoreplaceRule.objects.filter(language__id=self.lang,</pre></div>
<div class="cov"><span class="num"><pre> 88</pre></span><pre>                                                          family='autocorrect'):</pre></div>
<div class="cov"><span class="num"><pre> 89</pre></span><pre>            autocorrect[replacerule.match] = replacerule.replace_with</pre></div>
<div class="cov"><span class="num"><pre> 90</pre></span><pre>        return autocorrect</pre></div>
<div class="skip"><span class="num"><pre> 91</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 92</pre></span><pre>    def tokenize(self, text):</pre></div>
<div class="cov"><span class="num"><pre> 93</pre></span><pre>        r&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 94</pre></span><pre>        Tokenizing a sentence inserts spaces in such a way that it separates</pre></div>
<div class="cov"><span class="num"><pre> 95</pre></span><pre>        punctuation from words, splits up contractions, and generally does what</pre></div>
<div class="cov"><span class="num"><pre> 96</pre></span><pre>        a lot of natural language tools (especially parsers) expect their</pre></div>
<div class="cov"><span class="num"><pre> 97</pre></span><pre>        input to do.</pre></div>
<div class="skip"><span class="num"><pre> 98</pre></span><pre>        </pre></div>
<div class="cov"><span class="num"><pre> 99</pre></span><pre>            &gt;&gt;&gt; en_nl.tokenize(&quot;Time is an illusion. Lunchtime, doubly so.&quot;)</pre></div>
<div class="cov"><span class="num"><pre>100</pre></span><pre>            'Time is an illusion . Lunchtime , doubly so .'</pre></div>
<div class="cov"><span class="num"><pre>101</pre></span><pre>            &gt;&gt;&gt; untok = '''</pre></div>
<div class="cov"><span class="num"><pre>102</pre></span><pre>            ... &quot;Very deep,&quot; said Arthur, &quot;you should send that in to the</pre></div>
<div class="cov"><span class="num"><pre>103</pre></span><pre>            ... Reader's Digest. They've got a page for people like you.&quot;</pre></div>
<div class="cov"><span class="num"><pre>104</pre></span><pre>            ... '''</pre></div>
<div class="cov"><span class="num"><pre>105</pre></span><pre>            &gt;&gt;&gt; tok = en_nl.tokenize(untok)</pre></div>
<div class="cov"><span class="num"><pre>106</pre></span><pre>            &gt;&gt;&gt; tok</pre></div>
<div class="cov"><span class="num"><pre>107</pre></span><pre>            &quot;`` Very deep , '' said Arthur , `` you should send that in to the Reader 's Digest . They 've got a page for people like you . ''&quot;</pre></div>
<div class="cov"><span class="num"><pre>108</pre></span><pre>            &gt;&gt;&gt; en_nl.untokenize(tok)</pre></div>
<div class="cov"><span class="num"><pre>109</pre></span><pre>            '&quot;Very deep,&quot; said Arthur, &quot;you should send that in to the Reader\'s Digest. They\'ve got a page for people like you.&quot;'</pre></div>
<div class="cov"><span class="num"><pre>110</pre></span><pre>            &gt;&gt;&gt; en_nl.untokenize(tok) == untok.replace('\n', ' ').strip()</pre></div>
<div class="cov"><span class="num"><pre>111</pre></span><pre>            True</pre></div>
<div class="skip"><span class="num"><pre>112</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>113</pre></span><pre>        &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>114</pre></span><pre>        step0 = text.replace('\r', '').replace('\n', ' ')</pre></div>
<div class="cov"><span class="num"><pre>115</pre></span><pre>        step1 = step0.replace(&quot; '&quot;, &quot; ` &quot;).replace(&quot;'&quot;, &quot; '&quot;).replace(&quot;n 't&quot;, </pre></div>
<div class="cov"><span class="num"><pre>116</pre></span><pre>        &quot; n't&quot;).replace(&quot;cannot&quot;, &quot;can not&quot;)</pre></div>
<div class="cov"><span class="num"><pre>117</pre></span><pre>        step2 = re.sub('&quot;([^&quot;]*)&quot;', r&quot; `` \1 '' &quot;, step1)</pre></div>
<div class="cov"><span class="num"><pre>118</pre></span><pre>        step3 = re.sub(r'([.,:;?!%]+) ', r&quot; \1 &quot;, step2)</pre></div>
<div class="cov"><span class="num"><pre>119</pre></span><pre>        step4 = re.sub(r'([.,:;?!%]+)$', r&quot; \1&quot;, step3)</pre></div>
<div class="cov"><span class="num"><pre>120</pre></span><pre>        step5 = re.sub(r'([()])', r&quot; \1 &quot;, step4)</pre></div>
<div class="cov"><span class="num"><pre>121</pre></span><pre>        return re.sub(r'  +', ' ', step5).strip()</pre></div>
<div class="skip"><span class="num"><pre>122</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>123</pre></span><pre>    def untokenize(self, text):</pre></div>
<div class="cov"><span class="num"><pre>124</pre></span><pre>        &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>125</pre></span><pre>        Untokenizing a text undoes the tokenizing operation, restoring</pre></div>
<div class="cov"><span class="num"><pre>126</pre></span><pre>        punctuation and spaces to the places that people expect them to be.</pre></div>
<div class="skip"><span class="num"><pre>127</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>128</pre></span><pre>        Ideally, `untokenize(tokenize(text))` should be identical to `text`,</pre></div>
<div class="cov"><span class="num"><pre>129</pre></span><pre>        except for line breaks.</pre></div>
<div class="cov"><span class="num"><pre>130</pre></span><pre>        &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>131</pre></span><pre>        step1 = text.replace(&quot;`` &quot;, '&quot;').replace(&quot; ''&quot;, '&quot;')</pre></div>
<div class="cov"><span class="num"><pre>132</pre></span><pre>        step2 = step1.replace(&quot; ( &quot;, &quot; (&quot;).replace(&quot; ) &quot;, &quot;) &quot;)</pre></div>
<div class="cov"><span class="num"><pre>133</pre></span><pre>        step3 = re.sub(r' ([.,:;?!%]+)([ \'&quot;`])', r&quot;\1\2&quot;, step2)</pre></div>
<div class="cov"><span class="num"><pre>134</pre></span><pre>        step4 = re.sub(r' ([.,:;?!%]+)$', r&quot;\1&quot;, step3)</pre></div>
<div class="cov"><span class="num"><pre>135</pre></span><pre>        step5 = step4.replace(&quot; '&quot;, &quot;'&quot;).replace(&quot; n't&quot;, &quot;n't&quot;).replace(</pre></div>
<div class="cov"><span class="num"><pre>136</pre></span><pre>          &quot;can not&quot;, &quot;cannot&quot;)</pre></div>
<div class="cov"><span class="num"><pre>137</pre></span><pre>        step6 = step5.replace(&quot; ` &quot;, &quot; '&quot;)</pre></div>
<div class="cov"><span class="num"><pre>138</pre></span><pre>        return step6.strip()</pre></div>
<div class="skip"><span class="num"><pre>139</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>140</pre></span><pre>    def canonicalize(self, word):</pre></div>
<div class="cov"><span class="num"><pre>141</pre></span><pre>        &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>142</pre></span><pre>        Reduce equivalent characters to a canonical form.</pre></div>
<div class="skip"><span class="num"><pre>143</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>144</pre></span><pre>        In a EuroNL, by default, this puts those characters in lowercase.</pre></div>
<div class="cov"><span class="num"><pre>145</pre></span><pre>        &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>146</pre></span><pre>        return word.lower()</pre></div>
<div class="skip"><span class="num"><pre>147</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>148</pre></span><pre>    def is_stopword(self, word):</pre></div>
<div class="cov"><span class="num"><pre>149</pre></span><pre>        &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>150</pre></span><pre>        A *stopword* is a word that contributes little to the semantic meaning</pre></div>
<div class="cov"><span class="num"><pre>151</pre></span><pre>        of a text and should be ignored. These tend to be short, common words</pre></div>
<div class="cov"><span class="num"><pre>152</pre></span><pre>        such as &quot;of&quot;, &quot;the&quot;, and &quot;you&quot;.</pre></div>
<div class="skip"><span class="num"><pre>153</pre></span><pre>        </pre></div>
<div class="cov"><span class="num"><pre>154</pre></span><pre>        Stopwords are often members of closed classes such as articles and</pre></div>
<div class="cov"><span class="num"><pre>155</pre></span><pre>        prepositions.</pre></div>
<div class="skip"><span class="num"><pre>156</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>157</pre></span><pre>        Whether a word is a stopword or not is a judgement call that depends on</pre></div>
<div class="cov"><span class="num"><pre>158</pre></span><pre>        the application. In ConceptNet, we began with the stock lists of</pre></div>
<div class="cov"><span class="num"><pre>159</pre></span><pre>        stopwords from NLTK, but we have refined and tweaked the lists</pre></div>
<div class="cov"><span class="num"><pre>160</pre></span><pre>        (especially in English) over the years.</pre></div>
<div class="skip"><span class="num"><pre>161</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>162</pre></span><pre>        Examples::</pre></div>
<div class="skip"><span class="num"><pre>163</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>164</pre></span><pre>            &gt;&gt;&gt; en_nl.is_stopword('the')</pre></div>
<div class="cov"><span class="num"><pre>165</pre></span><pre>            True</pre></div>
<div class="cov"><span class="num"><pre>166</pre></span><pre>            &gt;&gt;&gt; en_nl.is_stopword('THE')</pre></div>
<div class="cov"><span class="num"><pre>167</pre></span><pre>            True</pre></div>
<div class="cov"><span class="num"><pre>168</pre></span><pre>            &gt;&gt;&gt; en_nl.is_stopword('defenestrate')</pre></div>
<div class="cov"><span class="num"><pre>169</pre></span><pre>            False</pre></div>
<div class="skip"><span class="num"><pre>170</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>171</pre></span><pre>            &gt;&gt;&gt; pt_nl = get_nl('pt')      # This time, in Portuguese</pre></div>
<div class="cov"><span class="num"><pre>172</pre></span><pre>            &gt;&gt;&gt; pt_nl.is_stopword('os')</pre></div>
<div class="cov"><span class="num"><pre>173</pre></span><pre>            True</pre></div>
<div class="cov"><span class="num"><pre>174</pre></span><pre>            &gt;&gt;&gt; pt_nl.is_stopword('the')</pre></div>
<div class="cov"><span class="num"><pre>175</pre></span><pre>            False</pre></div>
<div class="cov"><span class="num"><pre>176</pre></span><pre>        &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>177</pre></span><pre>        return self.canonicalize(word) in self.stopwords</pre></div>
<div class="skip"><span class="num"><pre>178</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>179</pre></span><pre>    def is_blacklisted(self, text):</pre></div>
<div class="cov"><span class="num"><pre>180</pre></span><pre>        &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>181</pre></span><pre>        The blacklist is used to discover and discard particularly unhelpful</pre></div>
<div class="cov"><span class="num"><pre>182</pre></span><pre>        phrases.</pre></div>
<div class="skip"><span class="num"><pre>183</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>184</pre></span><pre>        A phrase is considered &quot;blacklisted&quot; if *every* word in it appears on</pre></div>
<div class="cov"><span class="num"><pre>185</pre></span><pre>        the blacklist. The empty string is always blacklisted.</pre></div>
<div class="skip"><span class="num"><pre>186</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>187</pre></span><pre>            &gt;&gt;&gt; en_nl.is_blacklisted('x')</pre></div>
<div class="cov"><span class="num"><pre>188</pre></span><pre>            True</pre></div>
<div class="cov"><span class="num"><pre>189</pre></span><pre>            &gt;&gt;&gt; en_nl.is_blacklisted('the')</pre></div>
<div class="cov"><span class="num"><pre>190</pre></span><pre>            False</pre></div>
<div class="cov"><span class="num"><pre>191</pre></span><pre>            &gt;&gt;&gt; en_nl.is_blacklisted('a b c d')</pre></div>
<div class="cov"><span class="num"><pre>192</pre></span><pre>            True</pre></div>
<div class="cov"><span class="num"><pre>193</pre></span><pre>            &gt;&gt;&gt; en_nl.is_blacklisted('a b c d puppies')</pre></div>
<div class="cov"><span class="num"><pre>194</pre></span><pre>            False</pre></div>
<div class="skip"><span class="num"><pre>195</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>196</pre></span><pre>        &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>197</pre></span><pre>        if not isinstance(text, unicode): text = text.decode('utf-8')</pre></div>
<div class="cov"><span class="num"><pre>198</pre></span><pre>        words = self.tokenize(text).split(' ')</pre></div>
<div class="cov"><span class="num"><pre>199</pre></span><pre>        for word in words:</pre></div>
<div class="cov"><span class="num"><pre>200</pre></span><pre>            if self.canonicalize(word) not in self.blacklist: return False</pre></div>
<div class="cov"><span class="num"><pre>201</pre></span><pre>        return True</pre></div>
<div class="skip"><span class="num"><pre>202</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>203</pre></span><pre>    def is_frequency(self, word):</pre></div>
<div class="cov"><span class="num"><pre>204</pre></span><pre>        &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>205</pre></span><pre>        Return whether this word represents a frequency.</pre></div>
<div class="skip"><span class="num"><pre>206</pre></span><pre>            </pre></div>
<div class="cov"><span class="num"><pre>207</pre></span><pre>            &gt;&gt;&gt; en_nl = get_nl('en')</pre></div>
<div class="cov"><span class="num"><pre>208</pre></span><pre>            &gt;&gt;&gt; en_nl.is_frequency('sometimes')</pre></div>
<div class="cov"><span class="num"><pre>209</pre></span><pre>            True</pre></div>
<div class="cov"><span class="num"><pre>210</pre></span><pre>            &gt;&gt;&gt; en_nl.is_frequency('somewhere')</pre></div>
<div class="cov"><span class="num"><pre>211</pre></span><pre>            False</pre></div>
<div class="skip"><span class="num"><pre>212</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>213</pre></span><pre>            &gt;&gt;&gt; es_nl = get_nl('es')      # This time, in Spanish</pre></div>
<div class="cov"><span class="num"><pre>214</pre></span><pre>            &gt;&gt;&gt; es_nl.is_frequency('nunca')</pre></div>
<div class="cov"><span class="num"><pre>215</pre></span><pre>            True</pre></div>
<div class="cov"><span class="num"><pre>216</pre></span><pre>            &gt;&gt;&gt; es_nl.is_frequency('never')</pre></div>
<div class="cov"><span class="num"><pre>217</pre></span><pre>            False</pre></div>
<div class="skip"><span class="num"><pre>218</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>219</pre></span><pre>        &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>220</pre></span><pre>        return self.canonicalize(word) in self.frequencies</pre></div>
<div class="skip"><span class="num"><pre>221</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>222</pre></span><pre>    def get_frequency(self, text):</pre></div>
<div class="cov"><span class="num"><pre>223</pre></span><pre>        &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>224</pre></span><pre>        If the text contains a frequency, return it. The first frequency that</pre></div>
<div class="cov"><span class="num"><pre>225</pre></span><pre>        occurs takes precedence, if there are multiple.</pre></div>
<div class="skip"><span class="num"><pre>226</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>227</pre></span><pre>            &gt;&gt;&gt; en_nl.get_frequency('Never trust a skinny chef.')</pre></div>
<div class="cov"><span class="num"><pre>228</pre></span><pre>            u'never'</pre></div>
<div class="cov"><span class="num"><pre>229</pre></span><pre>            &gt;&gt;&gt; en_nl.get_frequency('This statement is true.')</pre></div>
<div class="cov"><span class="num"><pre>230</pre></span><pre>            &gt;&gt;&gt; en_nl.get_frequency('This statement is not always true.')</pre></div>
<div class="cov"><span class="num"><pre>231</pre></span><pre>            u'not'</pre></div>
<div class="skip"><span class="num"><pre>232</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>233</pre></span><pre>        &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>234</pre></span><pre>        if not isinstance(text, unicode): text = text.decode('utf-8')</pre></div>
<div class="cov"><span class="num"><pre>235</pre></span><pre>        words = self.tokenize(text).split(' ')</pre></div>
<div class="cov"><span class="num"><pre>236</pre></span><pre>        for word in words:</pre></div>
<div class="cov"><span class="num"><pre>237</pre></span><pre>            if self.canonicalize(word) in self.frequencies:</pre></div>
<div class="cov"><span class="num"><pre>238</pre></span><pre>                return self.canonicalize(word)</pre></div>
<div class="cov"><span class="num"><pre>239</pre></span><pre>        return None</pre></div>
<div class="skip"><span class="num"><pre>240</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>241</pre></span><pre>class LemmatizedEuroNL(EuroNL):</pre></div>
<div class="cov"><span class="num"><pre>242</pre></span><pre>    @property</pre></div>
<div class="cov"><span class="num"><pre>243</pre></span><pre>    def lemmatizer(self):</pre></div>
<div class="cov"><span class="num"><pre>244</pre></span><pre>        &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>245</pre></span><pre>        The `.lemmatizer` property lazily loads an MBLEM lemmatizer from the</pre></div>
<div class="cov"><span class="num"><pre>246</pre></span><pre>        disk. The resulting object is an instance of</pre></div>
<div class="cov"><span class="num"><pre>247</pre></span><pre>        :class:`csc.nl.mblem.trie.Trie`.</pre></div>
<div class="cov"><span class="num"><pre>248</pre></span><pre>        &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>249</pre></span><pre>        if not hasattr(self, '_lemmatizer'):</pre></div>
<div class="cov"><span class="num"><pre>250</pre></span><pre>            from csc.nl.mblem import get_mblem</pre></div>
<div class="cov"><span class="num"><pre>251</pre></span><pre>            self._lemmatizer = get_mblem(self.lang)</pre></div>
<div class="cov"><span class="num"><pre>252</pre></span><pre>        return self._lemmatizer</pre></div>
<div class="skip"><span class="num"><pre>253</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>254</pre></span><pre>    @property</pre></div>
<div class="cov"><span class="num"><pre>255</pre></span><pre>    def unlemmatizer(self):</pre></div>
<div class="cov"><span class="num"><pre>256</pre></span><pre>        &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>257</pre></span><pre>        The `.unlemmatizer` property lazily loads an MBLEM unlemmatizer from</pre></div>
<div class="cov"><span class="num"><pre>258</pre></span><pre>        the disk. The resulting object is a dictionary of tries, one for each</pre></div>
<div class="cov"><span class="num"><pre>259</pre></span><pre>        possible combination of part-of-speech and inflection that can be</pre></div>
<div class="cov"><span class="num"><pre>260</pre></span><pre>        added.</pre></div>
<div class="cov"><span class="num"><pre>261</pre></span><pre>        &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>262</pre></span><pre>        if not hasattr(self, '_unlemmatizer'):</pre></div>
<div class="cov"><span class="num"><pre>263</pre></span><pre>            from csc.nl.mblem import get_unlem</pre></div>
<div class="cov"><span class="num"><pre>264</pre></span><pre>            self._unlemmatizer = get_unlem(self.lang)</pre></div>
<div class="cov"><span class="num"><pre>265</pre></span><pre>        return self._unlemmatizer</pre></div>
<div class="skip"><span class="num"><pre>266</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>267</pre></span><pre>    def word_split(self, word):</pre></div>
<div class="cov"><span class="num"><pre>268</pre></span><pre>        &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>269</pre></span><pre>        Divide a single word into a string representing its *lemma form* (its</pre></div>
<div class="cov"><span class="num"><pre>270</pre></span><pre>        base form without inflections), and a second string representing the</pre></div>
<div class="cov"><span class="num"><pre>271</pre></span><pre>        inflections that were removed.</pre></div>
<div class="skip"><span class="num"><pre>272</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>273</pre></span><pre>        Instead of abstract symbols for the inflection, we currently represent</pre></div>
<div class="cov"><span class="num"><pre>274</pre></span><pre>        inflections as their most common natural language string. For example,</pre></div>
<div class="cov"><span class="num"><pre>275</pre></span><pre>        the inflection string 's' represents both &quot;plural&quot; and &quot;third-person</pre></div>
<div class="cov"><span class="num"><pre>276</pre></span><pre>        singular&quot;.</pre></div>
<div class="skip"><span class="num"><pre>277</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>278</pre></span><pre>        This odd representation basically makes the assumption that, when two</pre></div>
<div class="cov"><span class="num"><pre>279</pre></span><pre>        inflections look the same, they will act the same on any word. Thus, we</pre></div>
<div class="cov"><span class="num"><pre>280</pre></span><pre>        can avoid trying to disambiguate different inflections when they will</pre></div>
<div class="cov"><span class="num"><pre>281</pre></span><pre>        never make a difference. (There are cases where this is not technically</pre></div>
<div class="cov"><span class="num"><pre>282</pre></span><pre>        correct, such as &quot;leafs/leaves&quot; in &quot;there were leaves on the ground&quot;</pre></div>
<div class="cov"><span class="num"><pre>283</pre></span><pre>        versus &quot;he leafs through the pages&quot;, but we don't lose sleep over it.)</pre></div>
<div class="skip"><span class="num"><pre>284</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>285</pre></span><pre>        &gt;&gt;&gt; en_nl.word_split(u'lemmatizing')</pre></div>
<div class="cov"><span class="num"><pre>286</pre></span><pre>        (u'lemmatize', u'ing')</pre></div>
<div class="cov"><span class="num"><pre>287</pre></span><pre>        &gt;&gt;&gt; en_nl.word_split(u'cow')</pre></div>
<div class="cov"><span class="num"><pre>288</pre></span><pre>        (u'cow', u'')</pre></div>
<div class="cov"><span class="num"><pre>289</pre></span><pre>        &gt;&gt;&gt; en_nl.word_split(u'went')</pre></div>
<div class="cov"><span class="num"><pre>290</pre></span><pre>        (u'go', u'ed')</pre></div>
<div class="cov"><span class="num"><pre>291</pre></span><pre>        &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>292</pre></span><pre>        try:</pre></div>
<div class="cov"><span class="num"><pre>293</pre></span><pre>            lemma, pos, infl = self.lemmatizer.mblem(word)[0]</pre></div>
<div class="cov"><span class="num"><pre>294</pre></span><pre>            residue = self.unlemmatizer[pos, infl].leaves()[0].add</pre></div>
<div class="cov"><span class="num"><pre>295</pre></span><pre>            return (lemma, residue)</pre></div>
<div class="nocov"><span class="num"><pre>296</pre></span><pre>        except IndexError:</pre></div>
<div class="nocov"><span class="num"><pre>297</pre></span><pre>            return (word, u'')</pre></div>
<div class="skip"><span class="num"><pre>298</pre></span><pre>        </pre></div>
<div class="cov"><span class="num"><pre>299</pre></span><pre>    def lemma_split(self, text, keep_stopwords=False):</pre></div>
<div class="cov"><span class="num"><pre>300</pre></span><pre>        &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>301</pre></span><pre>        When you *lemma split* or *lemma factor* a string, you get two strings</pre></div>
<div class="cov"><span class="num"><pre>302</pre></span><pre>        back:</pre></div>
<div class="skip"><span class="num"><pre>303</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>304</pre></span><pre>        1. The *normal form*, a string containing all the lemmas of the</pre></div>
<div class="cov"><span class="num"><pre>305</pre></span><pre>           non-stopwords in the string.</pre></div>
<div class="cov"><span class="num"><pre>306</pre></span><pre>        2. The *residue*, a string containing all the stopwords and the</pre></div>
<div class="cov"><span class="num"><pre>307</pre></span><pre>           inflections that were removed.</pre></div>
<div class="skip"><span class="num"><pre>308</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>309</pre></span><pre>        These two strings can be recombined with :meth:`lemma_combine`.</pre></div>
<div class="skip"><span class="num"><pre>310</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>311</pre></span><pre>            &gt;&gt;&gt; en_nl.lemma_split(&quot;This is the testiest test that ever was tested&quot;)</pre></div>
<div class="cov"><span class="num"><pre>312</pre></span><pre>            (u'testy test ever test', u'this is the 1iest 2 that 3 was 4ed')</pre></div>
<div class="cov"><span class="num"><pre>313</pre></span><pre>        &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>314</pre></span><pre>        if not isinstance(text, unicode): text = text.decode('utf-8')</pre></div>
<div class="cov"><span class="num"><pre>315</pre></span><pre>        text = self.tokenize(text)</pre></div>
<div class="cov"><span class="num"><pre>316</pre></span><pre>        punct = string.punctuation.replace(&quot;'&quot;, &quot;&quot;).replace('-',</pre></div>
<div class="cov"><span class="num"><pre>317</pre></span><pre>        '').replace(&quot;`&quot;, &quot;&quot;)</pre></div>
<div class="skip"><span class="num"><pre>318</pre></span><pre>        </pre></div>
<div class="cov"><span class="num"><pre>319</pre></span><pre>        words = text.replace('/', ' ').split()</pre></div>
<div class="cov"><span class="num"><pre>320</pre></span><pre>        words = [w.strip(punct).lower() for w in words]</pre></div>
<div class="cov"><span class="num"><pre>321</pre></span><pre>        words = [self.autocorrect.get(word, word) for word in words if word]</pre></div>
<div class="cov"><span class="num"><pre>322</pre></span><pre>        lemma_tuples = [self.word_split(word) for word in words]</pre></div>
<div class="cov"><span class="num"><pre>323</pre></span><pre>        lemmas_pre = []</pre></div>
<div class="cov"><span class="num"><pre>324</pre></span><pre>        residue_pre = []</pre></div>
<div class="cov"><span class="num"><pre>325</pre></span><pre>        lemma_index = 0</pre></div>
<div class="cov"><span class="num"><pre>326</pre></span><pre>        for i in range(len(words)):</pre></div>
<div class="cov"><span class="num"><pre>327</pre></span><pre>            if not keep_stopwords and words[i] in self.stopwords:</pre></div>
<div class="cov"><span class="num"><pre>328</pre></span><pre>                residue_pre.append((None, words[i]))</pre></div>
<div class="cov"><span class="num"><pre>329</pre></span><pre>            else:</pre></div>
<div class="cov"><span class="num"><pre>330</pre></span><pre>                lemmas_pre.append((lemma_tuples[i][0], lemma_index))</pre></div>
<div class="cov"><span class="num"><pre>331</pre></span><pre>                residue_pre.append((lemma_index, lemma_tuples[i][1]))</pre></div>
<div class="cov"><span class="num"><pre>332</pre></span><pre>                lemma_index += 1</pre></div>
<div class="skip"><span class="num"><pre>333</pre></span><pre>        #lemmas_pre.sort()</pre></div>
<div class="cov"><span class="num"><pre>334</pre></span><pre>        permute = [l[1] for l in lemmas_pre]</pre></div>
<div class="cov"><span class="num"><pre>335</pre></span><pre>        invpermute = [permute.index(i) for i in range(len(permute))]</pre></div>
<div class="cov"><span class="num"><pre>336</pre></span><pre>        lemmas = [l[0] for l in lemmas_pre]</pre></div>
<div class="cov"><span class="num"><pre>337</pre></span><pre>        lemmas = [self.swapdict.get(lemma, lemma) for lemma in lemmas]</pre></div>
<div class="skip"><span class="num"><pre>338</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>339</pre></span><pre>        residue = []</pre></div>
<div class="cov"><span class="num"><pre>340</pre></span><pre>        for lemma_index, ltext in residue_pre:</pre></div>
<div class="cov"><span class="num"><pre>341</pre></span><pre>            if lemma_index is None: residue.append(ltext)</pre></div>
<div class="cov"><span class="num"><pre>342</pre></span><pre>            else: residue.append(str(invpermute[lemma_index]+1) + ltext)</pre></div>
<div class="cov"><span class="num"><pre>343</pre></span><pre>        if len(lemmas) == 0 and not keep_stopwords:</pre></div>
<div class="nocov"><span class="num"><pre>344</pre></span><pre>            return self.lemma_split(text, keep_stopwords=True)</pre></div>
<div class="cov"><span class="num"><pre>345</pre></span><pre>        return (u' '.join(lemmas), u' '.join(residue))</pre></div>
<div class="cov"><span class="num"><pre>346</pre></span><pre>    lemma_factor = lemma_split</pre></div>
<div class="skip"><span class="num"><pre>347</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>348</pre></span><pre>    def normalize(self, text):</pre></div>
<div class="cov"><span class="num"><pre>349</pre></span><pre>        &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>350</pre></span><pre>        When you *normalize* a string (no relation to the operation of</pre></div>
<div class="cov"><span class="num"><pre>351</pre></span><pre>        normalizing a vector), you remove its stopwords and inflections so that</pre></div>
<div class="cov"><span class="num"><pre>352</pre></span><pre>        it becomes equivalent to similar strings.</pre></div>
<div class="skip"><span class="num"><pre>353</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>354</pre></span><pre>        Normalizing involves running :meth:`lemma_split` and keeping only the</pre></div>
<div class="cov"><span class="num"><pre>355</pre></span><pre>        first factor, thus discarding the information that would be used to</pre></div>
<div class="cov"><span class="num"><pre>356</pre></span><pre>        reconstruct the full string.</pre></div>
<div class="skip"><span class="num"><pre>357</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>358</pre></span><pre>            &gt;&gt;&gt; en_nl.normalize(&quot;This is the testiest test that ever was tested&quot;)</pre></div>
<div class="cov"><span class="num"><pre>359</pre></span><pre>            u'testy test ever test'</pre></div>
<div class="cov"><span class="num"><pre>360</pre></span><pre>        &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>361</pre></span><pre>        return self.lemma_split(text)[0]</pre></div>
<div class="cov"><span class="num"><pre>362</pre></span><pre>    normalize4 = normalize</pre></div>
<div class="skip"><span class="num"><pre>363</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>364</pre></span><pre>    def lemma_combine(self, lemmas, residue):</pre></div>
<div class="cov"><span class="num"><pre>365</pre></span><pre>        &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>366</pre></span><pre>        This is the inverse of :meth:`lemma_factor` -- it takes in a normal</pre></div>
<div class="cov"><span class="num"><pre>367</pre></span><pre>        form and a residue, and re-assembles them into a phrase that is</pre></div>
<div class="cov"><span class="num"><pre>368</pre></span><pre>        hopefully comprehensible.</pre></div>
<div class="skip"><span class="num"><pre>369</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>370</pre></span><pre>            &gt;&gt;&gt; en_nl.lemma_combine(u'testy test ever test',</pre></div>
<div class="cov"><span class="num"><pre>371</pre></span><pre>            ... u'this is the 1iest 2 that 3 was 4ed')</pre></div>
<div class="cov"><span class="num"><pre>372</pre></span><pre>            u'this is the testiest test that ever was tested'</pre></div>
<div class="cov"><span class="num"><pre>373</pre></span><pre>        &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>374</pre></span><pre>        words = []</pre></div>
<div class="cov"><span class="num"><pre>375</pre></span><pre>        lemmas = lemmas.split(' ')</pre></div>
<div class="cov"><span class="num"><pre>376</pre></span><pre>        for res in residue.split(' '):</pre></div>
<div class="cov"><span class="num"><pre>377</pre></span><pre>            if res and res[0] in '0123456789':</pre></div>
<div class="cov"><span class="num"><pre>378</pre></span><pre>                numstr, pos, infl = self.lemmatizer.mblem(res)[0]</pre></div>
<div class="cov"><span class="num"><pre>379</pre></span><pre>                while numstr[-1] not in '0123456789': numstr = numstr[:-1]</pre></div>
<div class="cov"><span class="num"><pre>380</pre></span><pre>                num = int(numstr)</pre></div>
<div class="cov"><span class="num"><pre>381</pre></span><pre>                inflected = self.unlemmatizer[pos, infl].unlem(lemmas[num-1])[0]</pre></div>
<div class="cov"><span class="num"><pre>382</pre></span><pre>                words.append(inflected)</pre></div>
<div class="cov"><span class="num"><pre>383</pre></span><pre>            else:</pre></div>
<div class="cov"><span class="num"><pre>384</pre></span><pre>                words.append(res)</pre></div>
<div class="cov"><span class="num"><pre>385</pre></span><pre>        return self.untokenize(' '.join(words))</pre></div>
<div class="skip"><span class="num"><pre>386</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>387</pre></span><pre>class StemmedEuroNL(EuroNL):</pre></div>
<div class="cov"><span class="num"><pre>388</pre></span><pre>    @property</pre></div>
<div class="cov"><span class="num"><pre>389</pre></span><pre>    def stemmer(self):</pre></div>
<div class="nocov"><span class="num"><pre>390</pre></span><pre>        if not hasattr(self, '_stemmer'):</pre></div>
<div class="nocov"><span class="num"><pre>391</pre></span><pre>            from Stemmer import Stemmer</pre></div>
<div class="nocov"><span class="num"><pre>392</pre></span><pre>            self._stemmer = Stemmer(self.lang)</pre></div>
<div class="nocov"><span class="num"><pre>393</pre></span><pre>        return self._stemmer</pre></div>
<div class="skip"><span class="num"><pre>394</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>395</pre></span><pre>    def stem_word(self, word):</pre></div>
<div class="nocov"><span class="num"><pre>396</pre></span><pre>        return self.stemmer.stemWord(word)</pre></div>
<div class="skip"><span class="num"><pre>397</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>398</pre></span><pre>    def word_split(self, word):</pre></div>
<div class="nocov"><span class="num"><pre>399</pre></span><pre>        stem = self.stem_word(word)</pre></div>
<div class="nocov"><span class="num"><pre>400</pre></span><pre>        residue = word[len(stem):]</pre></div>
<div class="nocov"><span class="num"><pre>401</pre></span><pre>        return (stem, residue)</pre></div>
<div class="skip"><span class="num"><pre>402</pre></span><pre>    </pre></div>
<div class="cov"><span class="num"><pre>403</pre></span><pre>    def is_stopword(self, word):</pre></div>
<div class="cov"><span class="num"><pre>404</pre></span><pre>        return word in self.old_stopwords</pre></div>
<div class="skip"><span class="num"><pre>405</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>406</pre></span><pre>    def normalize(self, text):</pre></div>
<div class="nocov"><span class="num"><pre>407</pre></span><pre>        if not isinstance(text, unicode): text = text.decode('utf-8')</pre></div>
<div class="nocov"><span class="num"><pre>408</pre></span><pre>        punct = string.punctuation.replace(&quot;'&quot;, &quot;&quot;)</pre></div>
<div class="nocov"><span class="num"><pre>409</pre></span><pre>        words = text.replace('/', ' ').replace('-', ' ').split()</pre></div>
<div class="nocov"><span class="num"><pre>410</pre></span><pre>        words = [w.strip(punct).lower() for w in words]</pre></div>
<div class="nocov"><span class="num"><pre>411</pre></span><pre>        words = [w for w in words if not self.is_stopword(w)]</pre></div>
<div class="nocov"><span class="num"><pre>412</pre></span><pre>        words = [self.stem_word(w) for w in words]</pre></div>
<div class="nocov"><span class="num"><pre>413</pre></span><pre>        words.sort()</pre></div>
<div class="nocov"><span class="num"><pre>414</pre></span><pre>        return u&quot; &quot;.join(words)</pre></div>
<div class="skip"><span class="num"><pre>415</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>416</pre></span><pre></pre></div>
</div>
</body>
</html>
